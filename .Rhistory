ml_deer<- read.csv("C:/Users/mason/Dropbox/git/students/Rachel Dziuba/data/deer_ml_data.csv")
require(gauseR)
# looks like telling R what is what (pred/prey), and what time vector is
prey_lagged<-get_lag(x = ml_deer$deer4, time = ml_deer$year)
# looks like telling R what is what (pred/prey), and what time vector is
prey_lagged<-get_lag(x = ml_deer$deer4, time = ml_deer$year)
head(ml_deer)
predator_lagged<-get_lag(x = ml_deer$ml_sight, time = ml_deer$year)
ml_deer<- read.csv("C:/Users/mason/Dropbox/git/students/Rachel Dziuba/data/deer_ml_data.csv")
ml_deer
require(gauseR)
# looks like telling R what is what (pred/prey), and what time vector is
prey_lagged<-get_lag(x = ml_deer$deer4, time = ml_deer$year)
predator_lagged<-get_lag(x = ml_deer$ml_sight, time = ml_deer$year)
# calculate percapita growth rates for each
prey_dNNdt<-percap_growth(x = prey_lagged$x, laggedx = prey_lagged$laggedx, dt = prey_lagged$dt)
predator_dNNdt<-percap_growth(x = predator_lagged$x,
laggedx = predator_lagged$laggedx, dt = predator_lagged$dt)
# fit linear models to dNNdt, based on average
# abundances between current and lagged time steps
prey_mod_dat<-data.frame(prey_dNNdt=prey_dNNdt, prey=prey_lagged$laggedx,
predator=predator_lagged$laggedx)
mod_prey<-lm(prey_dNNdt~prey+predator, data=prey_mod_dat)
predator_mod_dat<-data.frame(predator_dNNdt=predator_dNNdt,
predator=predator_lagged$laggedx, prey=prey_lagged$laggedx)
mod_predator<-lm(predator_dNNdt~predator+prey, data=predator_mod_dat)
# model summaries
summary(mod_prey)
summary(mod_predator)
# extract parameters
# growth rates
r1 <- unname(coef(mod_prey)["(Intercept)"])
r2 <- unname(coef(mod_predator)["(Intercept)"])
r2
# self-limitation
a11 <- unname(coef(mod_prey)["prey"])
a22 <- unname(coef(mod_predator)["predator"])
# effect of Pa on Pc
a12 <- unname(coef(mod_prey)["predator"])
# effect of Pc on Pa
a21 <- unname(coef(mod_predator)["prey"])
# run ODE:
# make parameter vector:
parms <- c(r1, r2, a11, a12, a21, a22)
initialN <- c(4, 0.1) #this is just a basic and standard starting point
out <- deSolve::ode(y=initialN, times=seq(1995, 2019, length=25), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 250))
legend("topright", c("Deer", "Mountain Lion"), col=c(1,2), lwd=2, lty=c(1,3))
# now, plot in points from data
points(ml_deer$year, ml_deer$ml_sight , col=2)
points(ml_deer$year, ml_deer$deer4, col=1)
opt_data<-data.frame(time=ml_deer$year, Prey=ml_deer$deer4,
Predator=ml_deer$ml_sight)
# Save the signs of the parameters -
# optimizer works in log space, so these
# must be specified separately
parm_signs<-sign(parms)
# parameter vector for optimizer -
# must be a vector with, first, the
# starting abundances in log space,
# and second, the parameter values,
# again in log space
pars<-c(log(initialN), log(abs(parms)))
# run optimizer
optout<-optim(par = pars, fn = lv_optim, hessian = TRUE,
opt_data=opt_data, parm_signs=parm_signs)
# extract parameter vector:
parms <- exp(optout$par[-c(1:2)])*parm_signs
initialN <- exp(optout$par[1:2])
out <- deSolve::ode(y=initialN, times=seq(1995, 2019, length=25), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 250))
legend("topright", c("Deer", "Mountain Lion"), col=c(1,2), lwd=2, lty=c(1,3))
# now, plot in points from data
points(ml_deer$year, ml_deer$ml_sight , col=2)
points(ml_deer$year, ml_deer$deer4, col=1)
#extract time and species data
time<-ml_deer$year
species<-data.frame(ml_deer$deer4, ml_deer$ml_sight)
colnames(species)<-c("Deer", "Mountain_Lions")
#run wrapper
gause_out<-gause_wrapper(time=time, species=species)
summary(gause_out)
gause_out
# I hate R-base figures, so export the results and I will make new ones:
p<- as.data.frame(gause_out$out)
plot(p$time, p$Deer)
plot(p$Mountain_Lions, p$Deer)
ml_deer<- read.csv("C:/Users/mason/Dropbox/git/students/Rachel Dziuba/data/deer_ml_data.csv")
require(gauseR)
# tell R what  what pred/prey is, and what time vector is
prey_lagged<-get_lag(x = ml_deer$deer4, time = ml_deer$year)
predator_lagged<-get_lag(x = ml_deer$ml_sight, time = ml_deer$year)
# calculate percapita growth rates for each
prey_dNNdt<-percap_growth(x = prey_lagged$x, laggedx = prey_lagged$laggedx, dt = prey_lagged$dt)
predator_dNNdt<-percap_growth(x = predator_lagged$x,
laggedx = predator_lagged$laggedx, dt = predator_lagged$dt)
# fit linear models to dNNdt, based on average
# abundances between current and lagged time steps
prey_mod_dat<-data.frame(prey_dNNdt=prey_dNNdt, prey=prey_lagged$laggedx,
predator=predator_lagged$laggedx)
mod_prey<-lm(prey_dNNdt~prey+predator, data=prey_mod_dat)
predator_mod_dat<-data.frame(predator_dNNdt=predator_dNNdt,
predator=predator_lagged$laggedx, prey=prey_lagged$laggedx)
mod_predator<-lm(predator_dNNdt~predator+prey, data=predator_mod_dat)
# model summaries
summary(mod_prey) #ptttt, looks like crap.
summary(mod_predator) # slightly worse than crap.
# extract parameters
# growth rates
r1 <- unname(coef(mod_prey)["(Intercept)"])
r2 <- unname(coef(mod_predator)["(Intercept)"])
# self-limitation
a11 <- unname(coef(mod_prey)["prey"])
a22 <- unname(coef(mod_predator)["predator"])
# effect of Pa on Pc
a12 <- unname(coef(mod_prey)["predator"])
# effect of Pc on Pa
a21 <- unname(coef(mod_predator)["prey"])
# run ODE:
# make parameter vector:
parms <- c(r1, r2, a11, a12, a21, a22)
initialN <- c(4, 0.1) #this is just a basic and standard starting point
out <- deSolve::ode(y=initialN, times=seq(1995, 2019, length=25), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 250))
legend("topright", c("Deer", "Mountain Lion"), col=c(1,2), lwd=2, lty=c(1,3))
# now, plot in points from data
points(ml_deer$year, ml_deer$ml_sight , col=2)
points(ml_deer$year, ml_deer$deer4, col=1)
ml_deer<- read.csv("C:/Users/mason/Dropbox/git/students/Rachel Dziuba/data/deer_ml_data.csv")
require(gauseR)
# tell R what  what pred/prey is, and what time vector is
prey_lagged<-get_lag(x = ml_deer$deer4, time = ml_deer$year)
predator_lagged<-get_lag(x = ml_deer$ml_sight, time = ml_deer$year)
# calculate percapita growth rates for each
prey_dNNdt<-percap_growth(x = prey_lagged$x, laggedx = prey_lagged$laggedx, dt = prey_lagged$dt)
predator_dNNdt<-percap_growth(x = predator_lagged$x,
laggedx = predator_lagged$laggedx, dt = predator_lagged$dt)
# fit linear models to dNNdt, based on average
# abundances between current and lagged time steps
prey_mod_dat<-data.frame(prey_dNNdt=prey_dNNdt, prey=prey_lagged$laggedx,
predator=predator_lagged$laggedx)
mod_prey<-lm(prey_dNNdt~prey+predator, data=prey_mod_dat)
predator_mod_dat<-data.frame(predator_dNNdt=predator_dNNdt,
predator=predator_lagged$laggedx, prey=prey_lagged$laggedx)
mod_predator<-lm(predator_dNNdt~predator+prey, data=predator_mod_dat)
# model summaries
summary(mod_prey) #ptttt, looks like crap.
summary(mod_predator) # slightly worse than crap.
# extract parameters
# growth rates
r1 <- unname(coef(mod_prey)["(Intercept)"])
r2 <- unname(coef(mod_predator)["(Intercept)"])
# self-limitation
a11 <- unname(coef(mod_prey)["prey"])
a22 <- unname(coef(mod_predator)["predator"])
# effect of Pa on Pc
a12 <- unname(coef(mod_prey)["predator"])
# effect of Pc on Pa
a21 <- unname(coef(mod_predator)["prey"])
# run ODE:
# make parameter vector:
parms <- c(r1, r2, a11, a12, a21, a22)
initialN <- c(4, 0.1) #this is just a basic and standard starting point
out <- deSolve::ode(y=initialN, times=seq(1995, 2019, length=25), func=lv_interaction, parms=parms)
matplot(out[,1], out[,-1], type="l",
xlab="time", ylab="N", col=c("black","red"), lty=c(1,3), lwd=2, ylim=c(0, 250))
legend("topright", c("Deer", "Mountain Lion"), col=c(1,2), lwd=2, lty=c(1,3))
# now, plot in points from data
points(ml_deer$year, ml_deer$ml_sight , col=2)
points(ml_deer$year, ml_deer$deer4, col=1)
parms
names(parms)
require(gauseR)
citation("gauseR")
?ode
citation(ode)
citation("ode")
citation()
setwd("C:/Users/mason/Dropbox/git/Vicia/")
dat<- read.csv("vicia_final_data.csv")
#correlation among traits
xmat<-as.matrix(cbind(dat$FD, dat$FL, dat$B))
colnames(xmat)<- c("FD", "FL", "B")
library(Hmisc)
rcorr(xmat)
#remove empty rows19.5
dat2<- dat[!is.na(dat$B), ]
dat2$PlantID<- as.factor(dat2$PlantID)
dat2$Branch<- as.factor(dat2$Branch)
dat2$Pos<- as.factor(dat2$Pos)
fit<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='poisson')
dat<- read.csv("vicia_final_data.csv")
dat$PlantID<- as.factor(dat$PlantID)
dat$Branch<- as.factor(dat$Branch)
dat$Pos<- as.factor(dat$Pos)
#seed set per plant (response)
seed<- aggregate(dat$seeds, by=list(dat$PlantID), sum)
seed$Group.1<- NULL
#calcualte total flower number
flw.no<- aggregate(as.numeric(dat$Pos), by=list(dat$PlantID), max)
flw.no$Group.1<- NULL
flw.no.vd<-as.matrix(flw.no)
flw.no.vd<- as.vector(flw.no.vd)
#calculate total number of branches
bno<- dat[c("PlantID", "Branch")]
bno$Branch<- as.numeric(bno$Branch)
branch.no<- aggregate(bno$Branch, by=list(bno$PlantID), max)
branch.no$Group.1<- NULL
branch.no<- as.matrix(branch.no)
branch.no<- as.vector(branch.no)
b.no<- as.data.frame(branch.no)
######
# Prepare functional predictors
B<- dat[c("PlantID","PosSeq", "B")]
FL<- dat[c("PlantID","PosSeq", "FL")]
FD<- dat[c("PlantID","PosSeq", "FD")]
size<- dat[c("PlantID", "PosSeq", "flw_vol")]
# Reshape into long-format matrix
long<- reshape(B, timevar="PosSeq", idvar=c("PlantID"), direction = "wide")
long$PlantID<- NULL
long<- as.matrix(long)
b<-long
long<- reshape(FL, timevar="PosSeq", idvar=c("PlantID"), direction = "wide")
long$PlantID<- NULL
long<- as.matrix(long)
FL<-long
long<- reshape(FD, timevar="PosSeq", idvar=c("PlantID"), direction = "wide")
long$PlantID<- NULL
long<- as.matrix(long)
FD<-long
long<- reshape(size, timevar="PosSeq", idvar=c("PlantID"), direction = "wide")
long$PlantID<- NULL
long<- as.matrix(long)
flw.size<-long
#load Refund
library(refund)
fit<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='poisson')
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='gaussian')
AIC(fit, fit1, fit2)# nb
summary(fit1)
#### spline type
fit<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "s", transform='standardized')
,family='nb')
fit2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "t2", transform='standardized')
,family='nb')
AIC(fit, fit1, fit2)# te basistype
summary(fit)
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1.1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no),family='nb')
fit1.1a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
, offset= unlist(flw.no),family='nb')
fit1.2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no) + unlist(b.no),family='nb')
fit1.2a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no), offset=unlist(flw.no) , family='nb')
fit1.3<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no),family='nb')
AIC(fit1, fit1.1, fit1.1a, fit1.2, fit1.2a, fit1.3)
summary(fit1.1)
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1.1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no),family='nb')
fit1.1a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
, offset= unlist(flw.no),family='nb')
fit1.2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no) + unlist(b.no),family='nb')
fit1.2a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no), offset=unlist(flw.no) , family='nb')
fit1.3<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no),family='nb')
AIC(fit1, fit1.1, fit1.1a, fit1.2, fit1.2a, fit1.3)
summary(fit1.1)
fit<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "s", transform='standardized')
,family='nb')
fit2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "t2", transform='standardized')
,family='nb')
AIC(fit, fit1, fit2)# te basistype
summary(fit)
fit<- coef(fit1)   #Note: are these transformed?
#make absolute frstart date
fit$x<- fit$FL.arg * fit$FL.vd
plot(fit$x, fit$value, type="l", main="absolute")
plot(fit$FL.arg, fit$value, type="l", main="relative")
summary(fit)
fit<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "s", transform='standardized')
,family='nb')
fit2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "t2", transform='standardized')
,family='nb')
AIC(fit, fit1, fit2)# te basistype
summary(fit)
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
fit1.1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no),family='nb')
fit1.1a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
, offset= unlist(flw.no),family='nb')
fit1.2<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(flw.no) + unlist(b.no),family='nb')
fit1.2a<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no), offset=unlist(flw.no) , family='nb')
fit1.3<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
+ unlist(b.no),family='nb')
AIC(fit1, fit1.1, fit1.1a, fit1.2, fit1.2a, fit1.3)
summary(fit)
fit<- coef(fit1)   #Note: are these transformed?
#make absolute frstart date
fit$x<- fit$FL.arg * fit$FL.vd
plot(fit$x, fit$value, type="l", main="absolute")
fit1<- pfr(seed ~ lf.vd(FL, vd=branch.no,basistype = "te", transform='standardized')
,family='nb')
summary(fit1)
